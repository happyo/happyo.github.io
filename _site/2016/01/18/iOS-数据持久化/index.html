<!DOCTYPE html>
<html lang="en">

<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Write your site description here. It will be used as your sites meta description as well!">

    <title>iOS 数据持久化 - Clean Blog</title>

    <link rel="canonical" href="http://localhost:4000/happyo/2016/01/18/iOS-%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/happyo/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/happyo/css/clean-blog.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/happyo/css/syntax.css">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href='//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <link type="application/atom+xml" rel="alternate" href="http://localhost:4000/happyo/feed.xml" title="Clean Blog" />

</head>


<body>

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/happyo/">Clean Blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                <li>
                    <a href="/happyo/">Home</a>
                </li>
                
				
                <li>
                    <a href="/happyo/about/">About</a>
                </li>
				
                
				
                <li>
                    <a href="/happyo/contact/">Contact</a>
                </li>
				
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>


    <!-- Post Header -->
<header class="intro-header" style="background-image: url('/happyo/img/post-bg-01.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>iOS 数据持久化</h1>
                    
                    <h2 class="subheading">because they lacked opposable thumbs and the brainpower to build a space program.</h2>
                    
                    <span class="meta">Posted by happyo on January 18, 2016</span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">

				<blockquote>
  <p>数据持久化即数据的永久存储。在 iOS 中，是将数据保存成文件，存储到程序的沙盒中。</p>
</blockquote>

<h2 id="沙盒"><strong>沙盒</strong></h2>
<ul>
  <li>
    <p><strong>每个 iOS 应用都有自己的应用沙盒，应用沙盒就是文件系统目录，与其他应用放入文件 系统隔离，iOS 系统不允许访问其他应用的应用沙盒，但在 ios8 中已经开放访问（extension）</strong></p>
  </li>
  <li>
    <p><strong>extension 是 iOS8 新开放的一种对几个固定系统区域的拓展机制，它可以在一定程度上弥补 iOS 的沙盒机制对应用间的通信限制</strong></p>
  </li>
  <li>
    <p><strong>应用沙盒一般包括以下几个文件目录:</strong></p>
  </li>
</ul>

<pre><code class="language-objective-c">.app
Documents
Library  
---Caches
---Preferences
tmp
</code></pre>

<h2 id="目录简介及获取"><strong>目录简介及获取</strong></h2>
<ul>
  <li><strong>沙盒根目录获取</strong>: 获取如下
    <pre><code class="language-objective-c">NSString *homePath = NSHomeDirectory();
NSLog(@"%@", homePath);
</code></pre>
    <p><br /></p>
  </li>
  <li><strong>.app文件</strong>: 这里面存放的是应用程序的源文件，包括资源文件和可执行文件。
    <pre><code class="language-objective-c">NSString *appPath = [[NSBundle mainBundle] bundlePath];
NSLog(@"%@", appPath);
</code></pre>
    <p><br /></p>
  </li>
  <li><strong>Documents</strong>: 保存应用运行时生成的需要持久化的数据，<code class="highlighter-rouge">iTunes</code> 会自动备份该目录。
    <pre><code class="language-objective-c">NSString *documentPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject;
NSLog(@"%@", documentPath);
</code></pre>
    <p><br /></p>
  </li>
  <li><strong>tmp</strong>: 保存应用运行时所需的临时数据，使用完毕后再将对应的文件从该目录删除，应用没有运行时，系统也可能会自动清理该目录下的文件，<code class="highlighter-rouge">iTunes</code> 不会同步该目录，iPhone 重启时该目录下的文件会丢失。
    <pre><code class="language-objective-c">NSString *tmpPath = NSTemporaryDirectory();
NSLog(@"%@", tmpPath);
</code></pre>
    <p><br /></p>
  </li>
  <li><strong>Library</strong>: 存储程序的默认设置和其他状态信息，<code class="highlighter-rouge">iTunes </code>会自动备份该目录。
    <pre><code class="language-objective-c">NSString *libraryPath = NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES).firstObject;
NSLog(@"%@", libraryPath);
</code></pre>
    <p><br /></p>
  </li>
  <li><strong>Library/Caches</strong>: 存放缓存文件，<code class="highlighter-rouge">iTunes</code>不会备份此目录，此目录下文件不会在应用退出时删除，一般存放体积比较大，不是很重要的资源
    <pre><code class="language-objective-c">NSString *cachesPath = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES).firstObject;
NSLog(@"%@", cachesPath);
</code></pre>
    <p><br /></p>
  </li>
  <li><strong>Library/Preferences</strong>: 保存应用的所有偏好设置，iOS 的 <code class="highlighter-rouge">Setting（设置）</code>会在该目录中查找应用的设置信息，iTunes会自动备份该目录。
    <pre><code class="language-objective-c">NSString *preferencesPath = NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES).firstObject;
preferencesPath = [preferencesPath stringByAppendingPathComponent:@"Preferences"];
NSLog(@"%@", preferencesPath);
</code></pre>
    <p><br /></p>
  </li>
</ul>

<h2 id="了解了沙盒的基本概念后就可以进行数据持久化啦ios-的数据持久化方式一般有以下-5-种"><strong>了解了沙盒的基本概念后就可以进行数据持久化啦，iOS 的数据持久化方式一般有以下 5 种</strong></h2>
<ol>
  <li><strong>plist（属性列表）</strong></li>
  <li><strong>preferences (NSUserDefaults)</strong></li>
  <li><strong>NSKeyedArchiver (归档)</strong></li>
  <li><strong>SQLite 3</strong></li>
  <li><strong>CoreData</strong></li>
</ol>

<p><br /></p>

<h2 id="plist属性列表"><strong>plist（属性列表）</strong></h2>
<p>属性列表文件是一种 <code class="highlighter-rouge">XML</code> 文件，<code class="highlighter-rouge">Foundation</code> 框架中的一些对象可以与属性列表文件互相转换，可转换的类型如下：</p>

<pre><code class="language-objective-c">NSArray;
NSMutableArray;
NSDictionary;
NSMutableDictionary;
NSData;
NSMutableData;
NSString;
NSMutableString;
NSNumber;
</code></pre>

<p><br /></p>

<h4 id="存储和使用">存储和使用</h4>
<pre><code class="language-objective-c">// 获取存储文件的路径
NSString *documentPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject;
NSString *fileName = [documentPath stringByAppendingPathComponent:@"storage.plist"];

// 存储
NSArray *array = @[@"hello", @"world"];
[array writeToFile:fileName atomically:YES];

// 读取
NSArray *result = [NSArray arrayWithContentsOfFile:fileName];
NSLog(@"result :%@", result);

// 当存入的数组含有 null 的时候写文件会失败
NSArray *modifyArray = @[@"hello", [NSNull null]];
[modifyArray writeToFile:fileName atomically:YES];

// 结果发现取出来的还是第一次存的数组
NSArray *modifyResult = [NSArray arrayWithContentsOfFile:fileName];
NSLog(@"modify result :%@", modifyResult);
</code></pre>

<p><br /></p>

<h4 id="运行结果"><strong>运行结果</strong></h4>
<p><img src="http://cl.ly/241B0p0t0g0o/Image%202016-01-18%20at%207.50.49%20%E4%B8%8B%E5%8D%88.png" alt="plistResult" /></p>

<p><br /></p>

<h4 id="注意"><strong>注意</strong></h4>

<ul>
  <li><strong>只有上面提到的特定类型才能用 plist 进行存储</strong></li>
  <li><strong><code class="highlighter-rouge">writeToFile: atomically:</code> 的<code class="highlighter-rouge">atomically</code>参数表示是否使用辅助文件。如果为 <code class="highlighter-rouge">YES</code>，则先写入到一个辅助文件，然后将辅助文件重新命名为目标文件，如果为 <code class="highlighter-rouge">NO</code>，则直接写入目标文件。</strong></li>
  <li><strong>当需要存的对象里面包含<code class="highlighter-rouge">NULL</code>时，存文件会失败。（很多情况下是服务端返回的数据包含 <code class="highlighter-rouge">null</code>，然后转化成对象存会失败）</strong></li>
</ul>

<p><br /></p>

<h2 id="preferences-nsuserdefaults"><strong>preferences (NSUserDefaults)</strong></h2>
<p><code class="highlighter-rouge">NSUserDefaults</code>是一个单例，在整个程序中只有一个实例对象，他可以用于数据的永久保存，而且简单实用。</p>
<pre><code class="language-objective-c">// 获取 NSUserDefaults 的单例对象
NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];

// 存储
[userDefaults setObject:@"happyo" forKey:@"name"];
[userDefaults setBool:YES forKey:@"isMale"];
[userDefaults setInteger:25 forKey:@"age"];

// 立即同步
[userDefaults synchronize];

// 读取
NSString *nameStr = [userDefaults objectForKey:@"name"];
BOOL isMale = [userDefaults boolForKey:@"isMale"];
NSInteger age = [userDefaults integerForKey:@"age"];

NSLog(@"name : %@, isMale :%d, age :%ld", nameStr, isMale, age);
</code></pre>

<p><br /></p>

<h4 id="结果如下"><strong>结果如下</strong></h4>

<p><img src="http://cl.ly/273C1L3t020W/Image%202016-01-18%20at%209.18.02%20%E4%B8%8B%E5%8D%88.png" alt="preferencesResult" /></p>

<h4 id="注意-1"><strong>注意</strong></h4>

<ul>
  <li><strong>偏好设置是专门用来保存应用程序的配置信息的，一般不要在偏好设置中保存其他数据。</strong></li>
  <li>**如果没有调用<code class="highlighter-rouge">synchronize</code>方法，系统会根据 I/O 情况不定时刻地保存到文件中。所以如果需要立即写入文件的就必须调用<code class="highlighter-rouge">synchronize</code>方法。 **</li>
  <li><strong>偏好设置会将所有数据保存到同一个文件中。即 <code class="highlighter-rouge">preference</code> 目录下的一个以此应用包名来命名的 plist 文件。</strong></li>
</ul>

<p><br /></p>

<h2 id="nskeyedarchiver-归档"><strong>NSKeyedArchiver (归档)</strong></h2>
<p>对象归档是一种序列化方式。为了便于数据传输，先将归档序列化成一个文件，然后通过返归档将数据恢复到对象中。
对一个对象进行完整归档需要满足的条件为：该对象的类必须实现<code class="highlighter-rouge">NSCoding</code>协议，而且每个成员变量应该是基本数据类型或者都是实现了<code class="highlighter-rouge">NSCoding</code>协议的某个类的实例。</p>

<p>创建一个<code class="highlighter-rouge">Car</code>类，使其实现<code class="highlighter-rouge">NSCoding</code>协议</p>
<pre><code class="language-objective-c">.h
@interface Car : NSObject &lt;NSCoding&gt;

@property (nonatomic, copy) NSString *name;

@property (nonatomic, assign) NSInteger speed;

@end

.m
@implementation Car

- (void)encodeWithCoder:(NSCoder *)aCoder
{
    [aCoder encodeObject:self.name forKey:@"name"];
    [aCoder encodeInteger:self.speed forKey:@"speed"];
}

- (instancetype)initWithCoder:(NSCoder *)aDecoder
{
    self.name = [aDecoder decodeObjectForKey:@"name"];
    self.speed = [aDecoder decodeIntegerForKey:@"speed"];

    return self;
}

@end
</code></pre>

<p>对其进行归档和解档</p>
<pre><code class="language-objective-c">// 创建对象
Car *car = [[Car alloc] init];
car.name = @"Aventador";
car.speed = 300;

// 获得存储路径
NSString *documentPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject;
NSString *fileName = [documentPath stringByAppendingString:@"car.data"];

// 归档
[NSKeyedArchiver archiveRootObject:car toFile:fileName];

// 解档
Car *unarchiveCar = [NSKeyedUnarchiver unarchiveObjectWithFile:fileName];

NSLog(@"car :%@ , speed :%ld", unarchiveCar.name, unarchiveCar.speed);
</code></pre>

<h4 id="注意-2"><strong>注意</strong></h4>
<ul>
  <li><strong>对象必须实现<code class="highlighter-rouge">NSCoding</code>协议</strong></li>
  <li><strong>保存文件的扩展名可以任意指定</strong></li>
  <li><strong>有继承关系时，要先调用父类的归解档方法</strong></li>
</ul>

<p><br /></p>

<h2 id="sqlite-3"><strong>SQLite 3</strong></h2>
<p><code class="highlighter-rouge">SQLite</code>是无数据类型的数据库，就是字段不用指定类型。虽然<code class="highlighter-rouge">SQLite</code>可以忽略数据类型，但从编程的规范上讲，应该在<code class="highlighter-rouge">Create Table</code>语句中指定数据类型。因为数据类型可以告知这个字段的含义，便于别人阅读和理解。<code class="highlighter-rouge">SQLite</code>支持的常见数据类型如下：</p>

<ul>
  <li><strong>INTEGER</strong>: 有符号的整数类型</li>
  <li><strong>REAL</strong>: 浮点类型</li>
  <li><strong>TEXT</strong>: 字符串类型，采用UTF-8和UTF-16字符编码</li>
  <li><strong>BLOB</strong>: 二进制大对象类型，能够存放任何二进制数据</li>
</ul>

<h4 id="首先添加类库"><strong>首先添加类库</strong></h4>
<p><img src="http://cl.ly/3D1M0P373W38/Image%202016-01-19%20at%2010.52.22%20%E4%B8%8A%E5%8D%88.png" alt="addLibrary" /></p>

<p>然后导入头文件</p>
<pre><code class="language-objective-c">#import &lt;sqlite3.h&gt;
</code></pre>

<p>在使用<code class="highlighter-rouge">SQLite</code>之前，我们先熟悉下它提供的一些方法</p>

<ul>
  <li><strong>sqlite3_open</strong>: 这个方法用于创建并且打开一个数据库文件。它提供了两个参数，第一个是数据库文件名，第二个是数据库句柄。如果文件不存在的话，他会先创建然后再打开，否则直接打开。</li>
  <li><strong>sqlite_prepare_v2</strong>: 这个方法的作用是，获得一个 string 类型的 SQL语句（查询语句），然后将其转化成可执行的语句。即检查 SQL语句的合法性。</li>
  <li><strong>sqlite_step</strong>: 在这个方法之前一般要执行预处理操作。当有数据返回时，它就会被调用。注意，不能在<code class="highlighter-rouge">sqlite_prepare_v2</code>之前调用它。</li>
  <li><strong>sqlite_finalize</strong>: 将预处理的语句删除掉</li>
  <li><strong>sqlite_column_count</strong>: 返回表里一共有多少列。</li>
  <li><strong>sqlite_column_text</strong>: 将指定的列数据变成<code class="highlighter-rouge">TEXT</code>类型返回。</li>
  <li><strong>sqlite_column_name</strong>: 返回列的名称</li>
  <li><strong>sqlite_exec</strong>: 它是对<code class="highlighter-rouge">[sqlite3_prepare_v2()]</code>, <code class="highlighter-rouge">[sqlite3_step()]</code>, 和 <code class="highlighter-rouge">[sqlite3_finalize()]</code>的一个封装，使我们执行 SQL的时候不用写太多的 c 代码。这个可以执行任意 SQL，例如插入，更新，删除，但一般查询的时候还是使用前3个方法。</li>
  <li><strong>sqlite_errmsg</strong>: 返回 SQLite 的错误描述</li>
  <li><strong>sqlite_close</strong>: 关闭数据库连接</li>
</ul>

<h4 id="创建表"><strong>创建表</strong></h4>
<pre><code class="language-objective-c">// 获取文件路径名
NSString *fileName = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject stringByAppendingString:@"person.sqlite"];

// 打开数据库
NSInteger openResult = sqlite3_open(fileName.UTF8String, &amp;myDb);
if (openResult == SQLITE_OK) {
    NSLog(@"打开数据库成功");

    // 创建表 SQL
    NSString *sqlCreateTable = @"CREATE TABLE IF NOT EXISTS person_info (ID INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT, age INTEGER)";
    char *errmsg = NULL;

    // 执行语句
    sqlite3_exec(myDb, sqlCreateTable.UTF8String, NULL, NULL, &amp;errmsg);

    if (errmsg) {
        NSLog(@"建表失败： %s", errmsg);
        return;
    } else {
        NSLog(@"建表成功");
    }

} else {
    NSLog(@"打开数据库失败");
    sqlite3_close(myDb);
    return;
}
</code></pre>

<h4 id="插入数据"><strong>插入数据</strong></h4>
<pre><code class="language-objective-c">// 插入10条数据
for (int i = 1; i &lt; 10; i++) {
    NSString *nameStr = [NSString stringWithFormat:@"happyo%i", i];
    NSInteger age = i;
    NSString *sqlInsertData = [NSString stringWithFormat:@"INSERT INTO person_info (name, age) VALUES ('%@', '%ld')",nameStr , age];

    // 执行语句
    sqlite3_exec(myDb, sqlInsertData.UTF8String, NULL, NULL, &amp;errmsg);

    if (errmsg) {
        NSLog(@"插入失败： %s", errmsg);
        return;
    }
}

NSLog(@"插入成功");
</code></pre>

<h4 id="查询"><strong>查询</strong></h4>
<pre><code class="language-objective-c">// 查询数据
NSString *sqlQuery = @"SELECT name, age FROM person_info";
sqlite3_stmt *stmt;

NSInteger queryResult = sqlite3_prepare_v2(myDb, sqlQuery.UTF8String, -1, &amp;stmt, NULL);
if (queryResult == SQLITE_OK) {
    while (sqlite3_step(stmt) == SQLITE_ROW) {
        char *name = (char *)sqlite3_column_text(stmt, 0);
        NSInteger age = sqlite3_column_int(stmt, 1);

        NSLog(@"name :%s , age :%ld", name, age);
    }
}

sqlite3_finalize(stmt);
</code></pre>

<p>由于原生的 SQLite 方法都是 c 写的，比较难用。所以一般在开发过程中，我们都使用第三方开源库 <code class="highlighter-rouge">FMDB</code> 。关于<code class="highlighter-rouge">FMDB</code>，<a href="http://blog.devtang.com/blog/2012/04/22/use-fmdb/">这里</a>有介绍使用的。</p>

<p><br /></p>

<h2 id="coredata"><strong>CoreData</strong></h2>
<p>对于<code class="highlighter-rouge">CoreData</code>，有很多相关的文章。推荐一个，<a href="https://www.objc.io/issues/4-core-data/core-data-overview/">Core Data Overview</a>，中文版<a href="http://objccn.io/issue-4-1/">Core Data 概述</a>。</p>

<p><br /></p>

<h4 id="相关文章"><strong>相关文章</strong></h4>
<ul>
  <li><a href="http://www.jianshu.com/p/2944233ebac4">iOS沙盒机制介绍</a></li>
  <li><a href="http://www.jianshu.com/p/7616cbd72845">我要永远地记住你！（iOS中几种数据持久化方案）</a></li>
  <li><a href="http://www.appcoda.com/sqlite-database-ios-app-tutorial/">SQLite 3 Functions Preview</a></li>
</ul>


                <hr>

                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/happyo/2016/01/12/%E6%B5%85%E8%B0%88NSString-copy%E4%B8%8Estrong%E7%9A%84%E5%8C%BA%E5%88%AB/" data-toggle="tooltip" data-placement="top" title="浅谈NSString copy与strong的区别">&larr; Previous Post</a>
                    </li>
                    
                    
                </ul>

            </div>
        </div>
    </div>
</article>

<hr>


    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    <li>
                        <a href="/happyo/feed.xml">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-rss fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    <li>
                        <a href="https://twitter.com/SBootstrap">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a href="https://www.facebook.com/StartBootstrap">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-facebook fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a href="https://github.com/happyo">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a href="mailto:happyojones@gmail.com">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-envelope fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                </ul>
                <p class="copyright text-muted">Copyright &copy; Your/Project/Corporate Name 2017</p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/happyo/js/jquery.min.js "></script>

<!-- Bootstrap Core JavaScript -->
<script src="/happyo/js/bootstrap.min.js "></script>

<!-- Custom Theme JavaScript -->
<script src="/happyo/js/clean-blog.min.js "></script>


    


</body>

</html>
